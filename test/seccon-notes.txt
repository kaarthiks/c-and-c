I Run dev version

cd c-and-c/
Look at the directories here.

cd working and create a file called start-vault:

vault server -dev &

Look at the message and especially the ones in yellow:

---
WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

You may need to set the following environment variable:

    $ export VAULT_ADDR='http://127.0.0.1:8200'

The unseal key and root token are displayed below in case you want to
seal/unseal the Vault or re-authenticate.

Unseal Key: nOsAKWPXt//6IJnG2CiccBFAYvN8dWLrOIXFuw5F7Ng=
Root Token: s.5xj2fCGkDtpkcI7GIqDS1LK6

Development mode should NOT be used in production installations!


---

The root token is very important. It is used to identify you as root, the owner of the vault instance. When you are logged in as the root token you have the power to do anything. And it is very frustrating that the root token is just a random string that we can potentially lose. So what we will do instead is to start vault but with a root token that we can easily remember.

vault server -dev -dev-root-token-id=root -dev-plugin-dir=/home/seccon/c-and-c/plugins &

In the above we are saying that the root token is root and we are also giving an additional parameter for the plugin directory. I will explain this later.

I suggest creating a shortcut to start vault. In case we have to do it often. So...

cat > start-vault.sh << EOF
#!/bin/bash
exec vault server -dev -dev-root-token-id=root -dev-plugin-dir=/home/seccon/c-and-c/plugins &
EOF

chmod +x start-vault.sh

killall -9 vault

./start-vault.sh

Look at the output that it generates.

----

WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

You may need to set the following environment variable:

    $ export VAULT_ADDR='http://127.0.0.1:8200'

The unseal key and root token are displayed below in case you want to
seal/unseal the Vault or re-authenticate.

Unseal Key: 2YCgZUQfB+Mso6xbmAQp4hrfYre2OGKkSH/F0REoUSo=
Root Token: root

The following dev plugins are registered in the catalog:
    - chakravyuh
    - chowkidar

Development mode should NOT be used in production installations!

----


Note the unseal key and root token. We set the root token as root. Copy the unseal key somewhere. I will explain what it means later.

Run

vault status

----

cat > my-unseal-key
WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

You may need to set the following environment variable:

    $ export VAULT_ADDR='http://127.0.0.1:8200'

The unseal key and root token are displayed below in case you want to
seal/unseal the Vault or re-authenticate.

Unseal Key: 2YCgZUQfB+Mso6xbmAQp4hrfYre2OGKkSH/F0REoUSo=
Root Token: root

The following dev plugins are registered in the catalog:
    - chakravyuh
    - chowkidar

Development mode should NOT be used in production installations!
----
one of the items in the text above is the web page. For this to work, we need to set the shell variable as listed. I have done that in your bashrc, and you can verify that it is set:

echo $VAULT_ADDR
http://127.0.0.1:8200



Data is stored in-memory, encrypted. Connection to localhost is without https, since we dont have trust anchor or server certs.

3. Now Launch firefox and go to http://127.0.0.1:8200

4 Sign in with method Token, and provide the Root Token: root

You can click around. You see the secrets tab, where you can store secrets. You can click on the auth tab and see the authenticaton methods. Currently there is only token based auth. You can click on "Enable new auth method" and you will see a bunch of auth methods.

If you can click on policies, you can see default and root. Click on the default policy - you see a language similar to json.

See the warning for the root policy.


II Lets create a secret

1. Click on secret

You will see that it says there are no secrets. So lets create one

In the path, say "myfirstsecret".

Ignore the secret metadata for now

Version data:
you can store key and value.
This is a key-value store, so lets store a key and value

key=my first key
value=i am learning something new!

When you say add, you will see space for a new key. So you can store multiple k-v pairs in the same path. So lets store second key

key=my second key
value=hope this is useful

Both key and value can be strings, with spaces, any characters, anything you want. There is no restriction here.

Note on the top, it shows breadcrumbs for the path to the secret, and on the bottom it shows the keys and values. You can also get a json output, so lets click that.


When you click that you get a json output. you can copy this and do something with it.

Also notice other buttons on the top:
a. version number
b. history
c. delete secret
d. copy secret
e. create new version

Lets go through each one of them.
click on version 1, you can see options - delete and permanently destroy the versions. I think these options are pretty straightforward to understand.

Click on history. You can see the version history here. We only have one version here, so nothing extra for us to see.

Now lets create a new version.

Click on create new version. Since we were in json mode, the editing section is now in json mode. If you are not comfortable with json mode, click on the json toggle in the top and you will get the easier mode.

lets make a change. we will add a new key-value pair first. and lets create something realistic.

So now you can see what the maximum versions mean - you can have a total of 10 such versions of the keys. when you enter the 11th, the 1st one is removed.

key="cec password"
value="i am definitely not giving it to you!"

so we saved it.

now you can see the key-value pairs in json as well as in easy format.

Notice on the top it says version 2. So you can play with this version. You can see the version history. You can click on specific versions to see what that version has. This is like a git log, in effect.

Now go to version 2, and click delete version. You can see the warning: the data is not removed from the storage but you can no longer read it. so lets do this.

Click on version history, you can see the two versions and version 2 is marked deleted.

Now click on version 2 and there is a undelete version. So lets undelete version 2. Now version 2 is undeleted and you can see it all again.

So this is an interesting way to manage secrets - do it all in a web interface, using tokens to login. Note that we used a root token, so we have complete access to all the data. Later on we will create new tokens and setup policies to control who can access what.


Any questions?

Now we have all this data, but web access is boring. How else do we access this data?
We have two options - cli and REST API.

So lets use both and try. We will start with cli.

Lets run this command:

vault kv get secret/myfirstsecret

====== Metadata ======
Key              Value
---              -----
created_time     2020-08-22T08:21:20.031522022Z
deletion_time    n/a
destroyed        false
version          2

======== Data ========
Key              Value
---              -----
my first key     i am learning something
my second key    hope this is useful
ssh key          my cec password


Notice the metadata as well as the data.

We can get a specific key using the following

vault kv get -field "ssh key" secret/myfirstsecret
my cec password


You can get via json format as well

vault kv get -format=json -field "ssh key" secret/myfirstsecret
"my cec password"

Lets get the whole secret as json format:

vault kv get -format=json secret/myfirstsecret
{
  "request_id": "a147150d-86d8-fd3f-2ca4-a4d6aa80c0fd",
  "lease_id": "",
  "lease_duration": 0,
  "renewable": false,
  "data": {
    "data": {
      "my first key": "i am learning something",
      "my second key": "hope this is useful",
      "ssh key": "my cec password"
    },
    "metadata": {
      "created_time": "2020-08-22T08:21:20.031522022Z",
      "deletion_time": "",
      "destroyed": false,
      "version": 2
    }
  },
  "warnings": null
}

Now, lets set a secret from the cli. So we set in K=V format:



vault kv put secret/myfirstsecret "secret from cli"="not my cec"
Key              Value
---              -----
created_time     2020-08-22T08:28:13.288390414Z
deletion_time    n/a
destroyed        false
version          3

Now look at the data:

vault kv get secret/myfirstsecret
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-22T08:28:13.288390414Z
deletion_time    n/a
destroyed        false
version          3

========= Data =========
Key                Value
---                -----
secret from cli    not my cec

"put" in the cli will *REPLACE* the existing secret, so we need to be careful. What we can do now is rollback to a previous state, using the rollback command. What we will do is notice the version number here is 3. So we want to rollback to version 2. So lets do that.

vault kv rollback -version=2 secret/myfirstsecret
Key              Value
---              -----
created_time     2020-08-22T08:29:45.983430212Z
deletion_time    n/a
destroyed        false
version          4

Note that rollback creates a new version, version 4 here. Lets look at the secret now.

vault kv get secret/myfirstsecret
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-22T08:29:45.983430212Z
deletion_time    n/a
destroyed        false
version          4

======== Data ========
Key              Value
---              -----
my first key     i am learning something
my second key    hope this is useful
ssh key          my cec password

Now lets check all these operations on the web ui.Go back to firefox. Click on myfirstsecret. you can see we are at version 4. Now click on history.

click on version 3 you can see what we did in version 3

So in the cli how do we append new data? You have to provide the previous data and the new data together.

vault kv put secret/myfirstsecret "my first key"="i am learning something" "my second key"="hope this is useful" "ssh key"="my cec password" "secret from cli"="not my cec"

Key              Value
---              -----
created_time     2020-08-22T08:33:27.414744656Z
deletion_time    n/a
destroyed        false
version          5
seccon@ubuntu:~$ vault kv get -format=json secret/myfirstsecret
{
  "request_id": "f96e2bcb-c31f-4e4a-037c-ce34f47227d5",
  "lease_id": "",
  "lease_duration": 0,
  "renewable": false,
  "data": {
    "data": {
      "my first key": "i am learning something",
      "my second key": "hope this is useful",
      "secret from cli": "not my cec",
      "ssh key": "my cec password"
    },
    "metadata": {
      "created_time": "2020-08-22T08:33:27.414744656Z",
      "deletion_time": "",
      "destroyed": false,
      "version": 5
    }
  },
  "warnings": null
}

seccon@ubuntu:~$ vault kv get secret/myfirstsecret
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-22T08:33:27.414744656Z
deletion_time    n/a
destroyed        false
version          5

========= Data =========
Key                Value
---                -----
my first key       i am learning something
my second key      hope this is useful
secret from cli    not my cec
ssh key            my cec password


You can see what other options are there:

vault kv -help
Usage: vault kv <subcommand> [options] [args]

  This command has subcommands for interacting with Vault's key-value
  store. Here are some simple examples, and more detailed examples are
  available in the subcommands or the documentation.

  Create or update the key named "foo" in the "secret" mount with the value
  "bar=baz":

      $ vault kv put secret/foo bar=baz

  Read this value back:

      $ vault kv get secret/foo

  Get metadata for the key:

      $ vault kv metadata get secret/foo
	  
  Get a specific version of the key:

      $ vault kv get -version=1 secret/foo

  Please see the individual subcommand help for detailed usage information.

Subcommands:
    delete               Deletes versions in the KV store
    destroy              Permanently removes one or more versions in the KV store
    enable-versioning    Turns on versioning for a KV store
    get                  Retrieves data from the KV store
    list                 List data or secrets
    metadata             Interact with Vault's Key-Value storage
    patch                Sets or updates data in the KV store without overwriting
    put                  Sets or updates data in the KV store
    rollback             Rolls back to a previous version of data
    undelete             Undeletes versions in the KV store
seccon@ubuntu:~$ 

You can get help for specific subcommands using -help after the subcommand. Most commands take a common set of parameters.

All of this is great, but the goal of a centralized secret storage mechanism is for applications running *ANYWHERE* to get the data. Humans can use the web UI and apps locally can run cli and parse (very ugly) but the best way to programmatically get all this inforamtion is REST. So lets take a look at that.


REST API

Lets set an environment variable for the token

seccon@ubuntu:~/chowkidar/working$ export VAULT_ROOT=root
VAULT_ROOT=root
VAULT_ADDR=http://127.0.0.1:8200

Look at rest-commands.txt to see how to run rest commands. Note that you need to change two parameters:
1. VAULT_TOKEN changed to the above root value. You can use either root or $VAULT_ROOT
2. path-to-secret must be replaced with actual path to the secret, in this case "myfirstsecret"

Now issue a REST GET for this secret:

curl \
>     --header "X-Vault-Token: $VAULT_ROOT" \
>     --request GET \
>     http://127.0.0.1:8200/v1/secret/data/myfirstsecret
{"request_id":"c3bdc387-a08d-fd70-629a-0fff8af16e05","lease_id":"","renewable":false,"lease_duration":0,"data":{"data":{"my first key":"i am learning something","my second key":"hope this is useful","secret from cli":"not my cec","ssh key":"my cec password"},"metadata":{"created_time":"2020-08-22T08:33:27.414744656Z","deletion_time":"","destroyed":false,"version":5}},"wrap_info":null,"warnings":null,"auth":null}

Use "| jq" to get a nicely formatted output

curl     --header "X-Vault-Token: $VAULT_ROOT"     --request GET     http://127.0.0.1:8200/v1/secret/data/myfirstsecret | jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   416  100   416    0     0  32000      0 --:--:-- --:--:-- --:--:-- 69333
{
  "request_id": "90e2a5bd-b437-cbbd-26a3-9af1b8702ab7",
  "lease_id": "",
  "renewable": false,
  "lease_duration": 0,
  "data": {
    "data": {
      "my first key": "i am learning something",
      "my second key": "hope this is useful",
      "secret from cli": "not my cec",
      "ssh key": "my cec password"
    },
    "metadata": {
      "created_time": "2020-08-22T08:33:27.414744656Z",
      "deletion_time": "",
      "destroyed": false,
      "version": 5
    }
  },
  "wrap_info": null,
  "warnings": null,
  "auth": null
}



Issue a GET for a different version:

curl \
>     --header "X-Vault-Token: $VAULT_ROOT" \
>     --request GET \
>     http://127.0.0.1:8200/v1/secret/data/myfirstsecret?version=1 | jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   357  100   357    0     0  59500      0 --:--:-- --:--:-- --:--:-- 59500
{
  "request_id": "7a18961d-04b6-1de2-0e68-cb018fbb996b",
  "lease_id": "",
  "renewable": false,
  "lease_duration": 0,
  "data": {
    "data": {
      "my first key": "i am learning something",
      "my second key": "hope this is useful"
    },
    "metadata": {
      "created_time": "2020-08-22T08:18:26.535943795Z",
      "deletion_time": "",
      "destroyed": false,
      "version": 1
    }
  },
  "wrap_info": null,
  "warnings": null,
  "auth": null
}

Lets update the secret using REST. For this you need a json formatted secret. You will find it in the file update-secret.json.

curl \
>     --header "X-Vault-Token: $VAULT_ROOT" \
>     --request POST \
>     --data @update-secret.json \
>     http://127.0.0.1:8200/v1/secret/data/myfirstsecret | jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   305  100   256  100    49  18285   3500 --:--:-- --:--:-- --:--:-- 25416
{
  "request_id": "624b89c0-cecd-bd4a-2f91-7987166ab2aa",
  "lease_id": "",
  "renewable": false,
  "lease_duration": 0,
  "data": {
    "created_time": "2020-08-22T09:26:18.839826869Z",
    "deletion_time": "",
    "destroyed": false,
    "version": 6
  },
  "wrap_info": null,
  "warnings": null,
  "auth": null
}



And now get the data again:

curl     --header "X-Vault-Token: $VAULT_ROOT"     --request GET     http://127.0.0.1:8200/v1/secret/data/myfirstsecret | jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   302  100   302    0     0  23230      0 --:--:-- --:--:-- --:--:-- 23230
{
  "request_id": "7c573d4b-8a8d-ed71-0714-860fb355036b",
  "lease_id": "",
  "renewable": false,
  "lease_duration": 0,
  "data": {
    "data": {
      "foo": "bar",
      "zip": "zap"
    },
    "metadata": {
      "created_time": "2020-08-22T09:26:18.839826869Z",
      "deletion_time": "",
      "destroyed": false,
      "version": 6
    }
  },
  "wrap_info": null,
  "warnings": null,
  "auth": null
}



We can use the REST API to delete specific versions. So lets first get the version #1

 curl \
>     --header "X-Vault-Token: $VAULT_ROOT" \
>     --request GET \
>     http://127.0.0.1:8200/v1/secret/data/myfirstsecret?version=1 | jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   357  100   357    0     0  35700      0 --:--:-- --:--:-- --:--:-- 51000
{
  "request_id": "5ee90489-daf6-0022-79dc-0cf5d0337e94",
  "lease_id": "",
  "renewable": false,
  "lease_duration": 0,
  "data": {
    "data": {
      "my first key": "i am learning something",
      "my second key": "hope this is useful"
    },
    "metadata": {
      "created_time": "2020-08-22T08:18:26.535943795Z",
      "deletion_time": "",
      "destroyed": false,
      "version": 1
    }
  },
  "wrap_info": null,
  "warnings": null,
  "auth": null
}


We will now delete this version. Use the use of the file delete-versions.json

Lets run this command

curl \
    --request POST \
    --data @delete-versions.json \
    http://127.0.0.1:8200/v1/secret/delete/myfirstsecret

curl \
>     --request POST \
>     --data @delete-versions.json \
>     http://127.0.0.1:8200/v1/secret/delete/myfirstsecret | jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100    55  100    36  100    19   4500   2375 --:--:-- --:--:-- --:--:--  6875
{
  "errors": [
    "missing client token"
  ]
}


Hey, look at that ! It says "permission denied". Why is that?
If you look at the curl request above, it does not have a token, thats why. So we will modify the request now to take the right VAULT_ROOT.

curl \
    --header "X-Vault-Token: $VAULT_ROOT" \
    --request POST \
    --data @delete-versions.json \
    http://127.0.0.1:8200/v1/secret/delete/myfirstsecret

And that worked. Now lets get version 1.


curl \
     --header "X-Vault-Token: $VAULT_ROOT" \
     --request GET \
     http://127.0.0.1:8200/v1/secret/data/myfirstsecret?version=1 |jq


curl \
>      --header "X-Vault-Token: $VAULT_ROOT" \
>      --request GET \
>      http://127.0.0.1:8200/v1/secret/data/myfirstsecret?version=1 |jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   310  100   310    0     0  28181      0 --:--:-- --:--:-- --:--:-- 28181
{
  "request_id": "1f0136b7-0ed7-43c7-d2ee-0ec3c4384124",
  "lease_id": "",
  "renewable": false,
  "lease_duration": 0,
  "data": {
    "data": null,
    "metadata": {
      "created_time": "2020-08-22T08:18:26.535943795Z",
      "deletion_time": "2020-08-22T09:29:43.795309695Z",
      "destroyed": false,
      "version": 1
    }
  },
  "wrap_info": null,
  "warnings": null,
  "auth": null
}


Look at that, it says no data in version 1. It is not destroyed, but data is null.

Now lets resurrect version 1 again.

curl \
    --header "X-Vault-Token: $VAULT_ROOT" \
    --request POST \
    --data @delete-versions.json \
    http://127.0.0.1:8200/v1/secret/undelete/myfirstsecret

Lets look at version 1 again.

curl \
      --header "X-Vault-Token: $VAULT_ROOT" \
      --request GET \
      http://127.0.0.1:8200/v1/secret/data/myfirstsecret?version=1 |jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   360  100   360    0     0  27692      0 --:--:-- --:--:-- --:--:-- 45000
curl \
>       --header "X-Vault-Token: $VAULT_ROOT" \
>       --request GET \
>       http://127.0.0.1:8200/v1/secret/data/myfirstsecret?version=1 |jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   357  100   357    0     0  27461      0 --:--:-- --:--:-- --:--:-- 35700
{
  "request_id": "be1c6ed6-b0c2-a7b9-afb0-743f8e3f9c81",
  "lease_id": "",
  "renewable": false,
  "lease_duration": 0,
  "data": {
    "data": {
      "my first key": "i am learning something",
      "my second key": "hope this is useful"
    },
    "metadata": {
      "created_time": "2020-08-22T08:18:26.535943795Z",
      "deletion_time": "",
      "destroyed": false,
      "version": 1
    }
  },
  "wrap_info": null,
  "warnings": null,
  "auth": null
}



And we are back. We can do this only because we deleted the version but didnt destroy it. This time we will destroy version 1 completely.

curl \
    --header "X-Vault-Token: $VAULT_ROOT" \
    --request POST \
    --data @delete-versions.json \
    http://127.0.0.1:8200/v1/secret/destroy/myfirstsecret

Now lets look at the data in version 1


curl \
       --header "X-Vault-Token: $VAULT_ROOT" \
       --request GET \
       http://127.0.0.1:8200/v1/secret/data/myfirstsecret?version=1 |jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   279  100   279    0     0  17437      0 --:--:-- --:--:-- --:--:-- 27900

{
  "request_id": "2e604c76-339f-ad9a-af52-ebb662702512",
  "lease_id": "",
  "renewable": false,
  "lease_duration": 0,
  "data": {
    "data": null,
    "metadata": {
      "created_time": "2020-08-22T08:18:26.535943795Z",
      "deletion_time": "",
      "destroyed": true,
      "version": 1
    }
  },
  "wrap_info": null,
  "warnings": null,
  "auth": null
}



So once again, null data but destroyed flag is true!

Lets try to resurrect this data now.

curl \
     --header "X-Vault-Token: $VAULT_ROOT" \
     --request POST \
     --data @delete-versions.json \
     http://127.0.0.1:8200/v1/secret/undelete/myfirstsecret

Can we see the version now?

curl \
        --header "X-Vault-Token: $VAULT_ROOT" \
        --request GET \
        http://127.0.0.1:8200/v1/secret/data/myfirstsecret?version=1 |jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   279  100   279    0     0  13950      0 --:--:-- --:--:-- --:--:-- 14684
{
  "request_id": "48964839-0fde-f563-9b34-9b5f4103f75e",
  "lease_id": "",
  "renewable": false,
  "lease_duration": 0,
  "data": {
    "data": null,
    "metadata": {
      "created_time": "2020-08-22T08:18:26.535943795Z",
      "deletion_time": "",
      "destroyed": true,
      "version": 1
    }
  },
  "wrap_info": null,
  "warnings": null,
  "auth": null
}

Nope, it is still destroyed.

So we have completely destroyed the version 1. Look into the web UI and see what it says there.

Look at the version history. You can see version 1 is destroyed. If you click on version 1 you will not see the data at all. You can look at the other versions and see the data in those versions.

Lets take version 2 and destroy it via cli:

You can get help for the cli using -help option, so here:

vault kv -help

will give you the commands you can run on the kv secrets type. You will see destroy in there, so lets do a help on that:

vault kv destroy -help

You can see that you can specify version number there, so lets use that.

vault kv destroy -versions=2 secret/myfirstsecret
Success! Data written to: secret/destroy/myfirstsecret

Back to the UI. And version 2 is destroyed as well.

Now lets create another secret but lets do it now via the cli

seccon@ubuntu:~/chowkidar/working$ vault kv put secret/mysecret "router password"="cisco123"
Key              Value
---              -----
created_time     2020-08-09T10:40:00.765903179Z
deletion_time    n/a
destroyed        false
version          1
seccon@ubuntu:~/chowkidar/working$ vault kv get secret/mysecret
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-09T10:40:00.765903179Z
deletion_time    n/a
destroyed        false
version          1

========= Data =========
Key                Value
---                -----
router password    cisco123


Lets look at this secret in the UI. You can also get the secret via REST:

curl \
     --header "X-Vault-Token: $VAULT_ROOT" \
     --request GET \
     http://127.0.0.1:8200/v1/secret/data/mysecret | jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   307  100   307    0     0  21928      0 --:--:-- --:--:-- --:--:-- 38375
{
  "request_id": "4c89b1ed-fae5-6535-df96-a8ad819f9fea",
  "lease_id": "",
  "renewable": false,
  "lease_duration": 0,
  "data": {
    "data": {
      "router password": "cisco123"
    },
    "metadata": {
      "created_time": "2020-08-23T05:45:00.434900505Z",
      "deletion_time": "",
      "destroyed": false,
      "version": 1
    }
  },
  "wrap_info": null,
  "warnings": null,
  "auth": null
}

Now you can list the secrets in the kv store:


Now lets see what secrets I have in all:

vault kv list secret
Keys
----
myfirstsecret
mysecret


So we have two paths where secrets are stored. You can look up each path and get the list of keys in each path. Remember that each secret can have any number of KV pairs, and you can get the specific one you want by using the -field option get. You can also get specific versions.

For instance:

vault kv get secret/myfirstsecret
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-22T09:26:18.839826869Z
deletion_time    n/a
destroyed        false
version          6

=== Data ===
Key    Value
---    -----
foo    bar
zip    zap
seccon@ubuntu:~/c-and-c/working$ vault kv get -field="foo" secret/myfirstsecret
bar

 vault kv get -version=4 secret/myfirstsecret
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-22T08:29:45.983430212Z
deletion_time    n/a
destroyed        false
version          4

======== Data ========
Key              Value
---              -----
my first key     i am learning something
my second key    hope this is useful
ssh key          my cec password
seccon@ubuntu:~/c-and-c/working$ vault kv get -field="my first key" -version=4 secret/myfirstsecret
i am learning something
seccon@ubuntu:~/c-and-c/working$ 

---- Delete

Ok, I think we have done enough damage to this object. Lets just kill it completely. Which way? CLI or GUI or REST? Here are the different ways to do it, you can try whichever one you want:


In the web interface, in the page for the secret, you can click on "delete secret" and then select delete.

In the cli, you can type:

vault kv delete secret/myfirstsecret
seccon@ubuntu:~/chowkidar/working$ vault kv get secret/myfirstsecret
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-09T10:13:57.790086168Z
deletion_time    2020-08-11T08:21:59.411196076Z
destroyed        false
version          9


Using REST: Note the request is DELETE, not POST, and the path is different - secret/*data*/myfirstsecret. To delete a version, you do a POST on secret/*delete*/myfirstsecret and you specify versions as data in json format.

curl \
     --header "X-Vault-Token: $VAULT_ROOT" \
     --request DELETE \
     http://127.0.0.1:8200/v1/secret/data/myfirstsecret

Get the data back and we get nothing:

curl \
     --header "X-Vault-Token: $VAULT_ROOT" \
     --request GET \
     http://127.0.0.1:8200/v1/secret/data/myfirstsecret | jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   310  100   310    0     0  25833      0 --:--:-- --:--:-- --:--:-- 25833
{
  "request_id": "d4f81491-fb46-7acd-de62-ddedaf72b1d0",
  "lease_id": "",
  "renewable": false,
  "lease_duration": 0,
  "data": {
    "data": null,
    "metadata": {
      "created_time": "2020-08-22T09:26:18.839826869Z",
      "deletion_time": "2020-08-23T05:49:24.00850061Z",
      "destroyed": false,
      "version": 6
    }
  },
  "wrap_info": null,
  "warnings": null,
  "auth": null
}



Lets list all the secrets: Note the path is secret/*metadata*/. And note that the "/" at the end is important - you need to specify a folder where the secrets are.

curl \
     --header "X-Vault-Token: $VAULT_ROOT" \
     --request LIST \
     http://127.0.0.1:8200/v1/secret/metadata/ | jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   196  100   196    0     0  32666      0 --:--:-- --:--:-- --:--:-- 49000
{
  "request_id": "ee800a55-8847-a486-c85b-7243e9a614e8",
  "lease_id": "",
  "renewable": false,
  "lease_duration": 0,
  "data": {
    "keys": [
      "myfirstsecret",
      "mysecret"
    ]
  },
  "wrap_info": null,
  "warnings": null,
  "auth": null
}


What if we didnt specify a folder? In this case lets try it on mysecret:


curl \
      --header "X-Vault-Token: $VAULT_ROOT" \
      --request LIST \
      http://127.0.0.1:8200/v1/secret/metadata/mysecret | jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100    14  100    14    0     0   1000      0 --:--:-- --:--:-- --:--:--  1076
{
  "errors": []
}

vault kv list secret/
Keys
----
mysecret
myfirstsecret

vault kv list secret/myfirstsecret
No value found at secret/metadata/myfirstsecret

vault kv list secret/mysecret
No value found at secret/metadata/mysecret


mysecret is not a folder in the path. It is just a key. We can create secrets that span folders.

seccon@ubuntu:~/chowkidar/working$ vault kv put secret/path/radius key=value1
Key              Value
---              -----
created_time     2020-08-11T08:34:57.667265744Z
deletion_time    n/a
destroyed        false
version          1
seccon@ubuntu:~/chowkidar/working$ vault kv put secret/path/tacacs key=value2
Key              Value
---              -----
created_time     2020-08-11T08:35:04.861215579Z
deletion_time    n/a
destroyed        false
version          1
seccon@ubuntu:~/chowkidar/working$ vault kv list secret/
Keys
----
mysecret
myfirstsecret
path/

seccon@ubuntu:~/chowkidar/working$ vault kv list secret/path
Keys
----
radius
tacacs

----

Plugins

Lets now talk about plugins. Until now we worked with the kv plugin, which is the key-value plugin. We can load lots of different types of plugins and they can be loaded into different paths in the folder structure. lets see the list of plugins.

vault plugin list
Plugins
-------
ad
alicloud
app-id
approle
aws
azure
cassandra
cassandra-database-plugin
centrify
cert
cf
consul
elasticsearch-database-plugin
gcp
gcpkms
github
hana-database-plugin
influxdb-database-plugin
jwt
kerberos
kubernetes
kv
ldap
mongodb
mongodb-database-plugin
mongodbatlas
mongodbatlas-database-plugin
mssql
mssql-database-plugin
mysql
mysql-aurora-database-plugin
mysql-database-plugin
mysql-legacy-database-plugin
mysql-rds-database-plugin
nomad
oci
oidc
okta
openldap
pcf
pki
postgresql
postgresql-database-plugin
rabbitmq
radius
redshift-database-plugin
ssh
totp
transit
userpass

There are 3 types of plugins - database, auth and secret. You can figure out which plugins do what:

vault plugin list auth
vault plugin list database
vault plugin list secret

we can enable a secrets plugin this way:

vault secrets enable -path=mykv kv
2020-08-11T01:49:30.274-0700 [INFO]  core: successful mount: namespace= path=mykv/ type=kv
Success! Enabled the kv secrets engine at: mykv/

Now we can do the same kv secrets using this new path:

vault kv put mykv/new/path key1=value1
Success! Data written to: mykv/new/path

vault kv get mykv/new/path
==== Data ====
Key     Value
---     -----
key1    value1

 vault kv list mykv/new/
Keys
----
path

vault kv list mykv/new/path
No value found at mykv/new/path/

 vault kv list mykv/
Keys
----
new/

seccon@ubuntu:~/chowkidar/working$ vault kv list mykv/new
Keys
----
path


We have been using "kv get/put". But the get/put operation is very specific to the kv plugin, which is why the subcommand get/put is after kv.

A more generic way is using vault read/write for any path, so lets do that.

vault read mykv/new/path
Key                 Value
---                 -----
refresh_interval    768h
key1                value1

vault write mykv/new/path key2=value2 key1=value1
Success! Data written to: mykv/new/path

vault kv get mykv/new/path
==== Data ====
Key     Value
---     -----
key1    value1
key2    value2

vault read mykv/new/path
Key                 Value
---                 -----
refresh_interval    768h
key1                value1
key2                value2



So we have done a lot with secrets. There are all sorts of secrets plugins and many of them require outside accounts like aws, azure, or a radius server. So based on what your purpose is, you can use one of these services. You can see whats really good about vault. You have a single place to map all secrets.

Now lets look at authentication.

Token Authentication
When we started vault we got root token, that is all powerful. We can create additional tokens that allow specific access.

VERY IMPORTANT: SAVE THE ROOT TOKEN!! I have it saved in VAULT_ROOT env variable.

echo $VAULT_ROOT
root

So lets create a new token.
vault token create
Key                  Value
---                  -----
token                s.v0sAa1fnMugw59hxjsQ7egQl
token_accessor       Rm6EsBtXLm9qEn9ZdihN57Kd
token_duration       ∞
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]

Notice the policies it has, which says root. This token inherits from root token, so it has all the powers of the root token. Lets login with this token.

 vault login s.EXXY8kmmtuTmTIXv5KSOIhNE
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                s.EXXY8kmmtuTmTIXv5KSOIhNE
token_accessor       InceOtW8yWKgt68BgH04uyhu
token_duration       ∞
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]

lets save this token somewhere safe.
export VAULT_MINE=s.EXXY8kmmtuTmTIXv5KSOIhNE

Since this token has the same capabilities as root, it can modify the secrets we created before. We can check it's capabilities using capabilities command.

vault token capabilities secrets/mysecret
root

seccon@ubuntu:~/chowkidar/working$ vault list mykv/new/
Keys
----
path


vault read mykv/new/path
Key                 Value
---                 -----
refresh_interval    768h
key1                value1
key2                value2

vault write mykv/new/path key3=value3
Success! Data written to: mykv/new/path

seccon@ubuntu:~/chowkidar/working$ vault read mykv/new/path
Key                 Value
---                 -----
refresh_interval    768h
key3                value3

We can lookup info about a token:

seccon@ubuntu:~/chowkidar/working$ vault token lookup
Key                 Value
---                 -----
accessor            Rm6EsBtXLm9qEn9ZdihN57Kd
creation_time       1597161944
creation_ttl        0s
display_name        token
entity_id           n/a
expire_time         <nil>
explicit_max_ttl    0s
id                  s.v0sAa1fnMugw59hxjsQ7egQl
issue_time          2020-08-11T09:05:44.024195226-07:00
meta                <nil>
num_uses            0
orphan              false
path                auth/token/create
policies            [root]
renewable           false
ttl                 0s
type                service

Notice the capabilities of this token - it shows the numbber of times you can use thet token, when it expires, etc. We havent set any of these, but we can. So if we set these policies appropriately for a token, we now have a fully featured way to provide access to others in a time limited or use limited manner. We can now pass this token to anyone else and they can use it to login and do some operations. Once they are done with the operations we can revoke the tokens.

vault token revoke s.v0sAa1fnMugw59hxjsQ7egQl
2020-08-11T09:15:08.110-0700 [INFO]  expiration: revoked lease: lease_id=auth/token/create/h2278564b8e0c96c11a81aeb92a7004e02e554fb8d98003fbc61ab812509e7eaf
Success! Revoked token (if it existed)

Now if we run any operations it should fail.

 vault read mykv/new/path
Error reading mykv/new/path: Error making API request.

URL: GET http://127.0.0.1:8200/v1/mykv/new/path
Code: 403. Errors:

* permission denied

So now we need to relogin, and as root since that is the only token we have.

vault login $VAULT_ROOT
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                s.nN5tsxOg9Yap2gG55tOTN4iT
token_accessor       AVJTkAbG7HSgUw3ku1LPshv2
token_duration       ∞
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]


--- REMOVE THIS ----

* Restarted vault

             Api Address: http://127.0.0.1:8200
                     Cgo: disabled
         Cluster Address: https://127.0.0.1:8201
              Go Version: go1.14.4
              Listener 1: tcp (addr: "127.0.0.1:8200", cluster address: "127.0.0.1:8201", max_request_duration: "1m30s", max_request_size: "33554432", tls: "disabled")
               Log Level: info
                   Mlock: supported: true, enabled: false
           Recovery Mode: false
                 Storage: inmem
                 Version: Vault v1.5.0

WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

You may need to set the following environment variable:

    $ export VAULT_ADDR='http://127.0.0.1:8200'

The unseal key and root token are displayed below in case you want to
seal/unseal the Vault or re-authenticate.

Unseal Key: poIcw0AopzyzX8EpWGlxlP5Nso6EcGjtZwpUaqrdeTM=
Root Token: s.ZSLtDt14LaaJtSfZlkloUEdX

---- REMOVE THI ------

Lets look at policies now. This is about authorization - who can do what. Written in a language called HCL.

In the UI, you can go to the Policies tab and look up the default policy. It lists a bunch of stuff there.


When you do vault token lookup, you can see the policies that apply:
Key                 Value
---                 -----
accessor            M8onuZldG32awXagS00naAJa
creation_time       1597476346
creation_ttl        0s
display_name        root
entity_id           n/a
expire_time         <nil>
explicit_max_ttl    0s
id                  s.ZSLtDt14LaaJtSfZlkloUEdX
meta                <nil>
num_uses            0
orphan              true
path                auth/token/root
policies            [root]
ttl                 0s
type                service


Run "vault policy list" and you will see:
default
root

Look at the policy (1) in policy.txt.

First we upload the policy to vault:

vault policy write mypolicy -<<EOF
path "mysecret/data/*" {
     capabilities = ["create", "update", "delete", "read"]
}

path "mysecret/data/locked" {
     capabilities = ["read"]
}
EOF
Success! Uploaded policy: mypolicy

Check that the policy says what we want it to say:

vault policy read mypolicy
path "secret/data/*" {
     capabilities = ["create", "update", "delete", "read"]
}

path "secret/data/locked" {
     capabilities = ["read"]
}

Now remember we are still running as root. Lets create some secrets in the paths specified in the hcl file. Dont use "data" - for kv plugin, the data is part of the path, similar to metadata.



seccon@ubuntu:~/c-and-c/working$ vault kv put secret/locked "my cec"="haha"
Key              Value
---              -----
created_time     2020-08-23T06:19:25.520279963Z
deletion_time    n/a
destroyed        false
version          1
seccon@ubuntu:~/c-and-c/working$ vault kv get secret/locked
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-23T06:19:25.520279963Z
deletion_time    n/a
destroyed        false
version          1

===== Data =====
Key       Value
---       -----
my cec    haha

Lets keep a list of secrets:

vault kv list secret/
Keys
----
locked
myfirstsecret
mysecret
path/

Now create the new user.
 vault token create -policy=mypolicy
Key                  Value
---                  -----
token                s.Pq4wSqy6S5CT8AdOY4TgzdRh
token_accessor       vfvrKs4YPYAuM9g8JWTb3U9o
token_duration       768h
token_renewable      true
token_policies       ["default" "mypolicy"]
identity_policies    []
policies             ["default" "mypolicy"]


seccon@ubuntu:~/chowkidar/working$ export VAULT_MINE=s.xEtUJjtMJQ2IpummmFiXzBb9
seccon@ubuntu:~/chowkidar/working$ env | grep VAULT

env | grep VAULT
VAULT_MINE=s.Pq4wSqy6S5CT8AdOY4TgzdRh
VAULT_ADDR=http://127.0.0.1:8200
VAULT_ROOT=root

Login as the new user

vault login $VAULT_MINE
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                s.Pq4wSqy6S5CT8AdOY4TgzdRh
token_accessor       vfvrKs4YPYAuM9g8JWTb3U9o
token_duration       767h58m27s
token_renewable      true
token_policies       ["default" "mypolicy"]
identity_policies    []
policies             ["default" "mypolicy"]

Lets check our capabilities:

vault token capabilities secret/data/locked
read

vault token capabilities secret/data/
create, delete, read, update


Read the locked secret

vault kv get secret/locked
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-23T06:19:25.520279963Z
deletion_time    n/a
destroyed        false
version          1

===== Data =====
Key       Value
---       -----
my cec    haha

Try to update the locked secret

vault kv put secret/locked "new key"="new data"
Error writing data to secret/data/locked: Error making API request.

URL: PUT http://127.0.0.1:8200/v1/secret/data/locked
Code: 403. Errors:

* 1 error occurred:
	* permission denied


Unable to delete either:

vault kv delete secret/locked
Error deleting secret/locked: Error making API request.

URL: DELETE http://127.0.0.1:8200/v1/secret/data/locked
Code: 403. Errors:

* 1 error occurred:
	* permission denied

We cannot list since we didnt give that permission:

vault kv list secret/
Error listing secret/metadata: Error making API request.

URL: GET http://127.0.0.1:8200/v1/secret/metadata?list=true
Code: 403. Errors:

* 1 error occurred:
	* permission denied


So we need to use the other secret by name. Its a good thing we saved the list of secrets before.

Lets look at the other secret.

vault kv get secret/myfirstsecret
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-22T09:26:18.839826869Z
deletion_time    2020-08-23T05:49:24.00850061Z
destroyed        false
version          6

vault kv get secret/mysecret
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-23T05:45:00.434900505Z
deletion_time    n/a
destroyed        false
version          1

========= Data =========
Key                Value
---                -----
router password    cisco123


Lets update this secret:

vault kv put secret/mysecret "router password"="lab123"
Key              Value
---              -----
created_time     2020-08-23T06:29:28.2106352Z
deletion_time    n/a
destroyed        false
version          2

vault kv get secret/mysecret
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-23T06:29:28.2106352Z
deletion_time    n/a
destroyed        false
version          2

========= Data =========
Key                Value
---                -----
router password    lab123

we can verify that this is modified for root user also:

 vault login $VAULT_ROOT
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                root
token_accessor       LxwXxE24AK2TNMl9PB3kvgaZ
token_duration       ∞
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]
seccon@ubuntu:~/c-and-c/working$ 
seccon@ubuntu:~/c-and-c/working$ 
seccon@ubuntu:~/c-and-c/working$ vault kv get secret/mysecret
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-23T06:29:28.2106352Z
deletion_time    n/a
destroyed        false
version          2

========= Data =========
Key                Value
---                -----
router password    lab123


Login back as the new user and create a new entry:

vault login $VAULT_MINE
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                s.xEtUJjtMJQ2IpummmFiXzBb9
token_accessor       Zcp0XSHxt3fb7ZUZ1rvJTL4Q
token_duration       767h37m11s
token_renewable      true
token_policies       ["default" "mypolicy"]
identity_policies    []
policies             ["default" "mypolicy"]

vault kv put secret/newpw newsshkey=123456
Key              Value
---              -----
created_time     2020-08-23T06:31:06.70920896Z
deletion_time    n/a
destroyed        false
version          1


vault kv get secret/newpw
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-15T17:28:03.74758151Z
deletion_time    n/a
destroyed        false
version          1

====== Data ======
Key          Value
---          -----
newsshkey    123456

Lets delete this entry

vault kv delete secret/newpw
Success! Data deleted (if it existed) at: mysecret/newpw

vault kv get secret/newpw
====== Metadata ======
Key              Value
---              -----
created_time     2020-08-15T17:28:03.74758151Z
deletion_time    2020-08-15T17:28:46.569744487Z
destroyed        false
version          1

So we can create, delete, read and update:

vault token capabilities secret/data/
create, delete, read, update

What about undelete?

vault kv undelete secret/newpw
No versions provided, use the "-versions" flag to specify the version to undelete.

vault kv undelete -versions=1 secret/newpw
Error writing data to secret/undelete/newpw: Error making API request.

URL: PUT http://127.0.0.1:8200/v1/mysecret/undelete/newpw
Code: 403. Errors:

* 1 error occurred:
	* permission denied

vault token capabilities secret/data/locked
read

vault delete secret/locked
Error deleting mysecret/locked: Error making API request.

URL: DELETE http://127.0.0.1:8200/v1/mysecret/locked
Code: 403. Errors:

* 1 error occurred:
	* permission denied


I can do all this via the REST API or the UI. Lets look at the UI


http://127.0.0.1:8200/ui/vault/secrets/secret/show/locked

http://127.0.0.1:8200/ui/vault/secrets/secret/show/myfirstsecret

http://127.0.0.1:8200/ui/vault/secrets/secret/show/newpw
http://127.0.0.1:8200/ui/vault/secrets/secret/show/mysecret



Now lets look at plugins. We have used the kv plugin. And we used policies to control access. We are now going to write two plugins. Lets look at the storage plugin first.
 The code is in ~/c-and-c/code/

Lets look at ~/c-and-c/code/chowkidar/.
 
Build using the go commands:
go build -o ~/c-and-c/plugins/chakravyuh
go build -o ~/c-and-c/plugins/chowkidar cmd/chowkidar/main.go

ls -l ~/c-and-c/plugins/

killall -9 vault

start vault now as:

./start-vault.sh


You also see this:

Unseal Key: Sthmy8OWDFkKIuo5TTU/KC/lnq1ksPB6G7EtYUI4Y80=
Root Token: root

The following dev plugins are registered in the catalog:
    - chakravyuh
    - chowkidar


You can list the plugins and you will be able to see them:

vault plugin list
Plugins
-------
[..]
chakravyuh
chowkidar
[..]

Now we can load the plugin into a specific location. Lets use the chowkidar plugin to store secrets.

vault secrets enable -path=chowkidar -plugin-name=chowkidar plugin

Success! Enabled the chowkidar secrets engine at: chowkidar/


vault auth enable -path=chakravyuh -plugin-name=chakravyuh plugin

Success! Enabled chakravyuh auth method at: chakravyuh/

This plugin allows two users to login:
user: app1, password: app1
user: app2, password: app2

Now we can use the chowkidar plugin to store secrets.

vault write chowkidar/test message="Hello world"

Success! Data written to: chowkidar/test

vault read chowkidar/test
Key        Value
---        -----
message    Hello world

We can also authenticate using chakravyuh

 vault write auth/chakravyuh/login username="app1" password="app1"


Key                  Value
---                  -----
token                s.hLCRNcYEGGXSQliutYCItCtJ
token_accessor       yBA6V4L1YXuEvFDlqAAmYkkQ
token_duration       50m
token_renewable      true
token_policies       ["default"]
identity_policies    []
policies             ["default"]

Note the policies are only default, not root+default. The duration is 50minutes for this token and then it has to be renewed. We can now login using this token.

vault login s.hLCRNcYEGGXSQliutYCItCtJ
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                s.hLCRNcYEGGXSQliutYCItCtJ
token_accessor       yBA6V4L1YXuEvFDlqAAmYkkQ
token_duration       49m10s
token_renewable      true
token_policies       ["default"]
identity_policies    []
policies             ["default"]
seccon@ubuntu:~/c-and-c/working$ 

seccon@ubuntu:~/c-and-c/working$ vault token capabilities chowkidar/test
deny

So using this token we dont have capability to read the location. We can create policy to read this space specifically. So, look in policy.txt and pick up the 2nd one.

vault policy write test -<<EOF
path "chowkidar/*" {
     capabilities = ["create", "update", "delete", "read"]
}
EOF
Error uploading policy: Error making API request.

URL: PUT http://127.0.0.1:8200/v1/sys/policies/acl/test
Code: 403. Errors:

* 1 error occurred:
	* permission denied

vault token lookup


Oh, right we are logged in as user "app1". SO lets login as root.

vault login $VAULT_ROOT
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                root
token_accessor       gzBXAqRupEtlL18v17FYalQr
token_duration       ∞
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]

vault policy write test -<<EOF
path "chowkidar/*" {
     capabilities = ["create", "update", "delete", "read"]
}
EOF

Success! Uploaded policy: test


vault policy read test
path "chowkidar/*" {
     capabilities = ["create", "update", "delete", "read"]
}

Now lets assign policy to the user app1

vault write auth/chakravyuh/role/app1 policies="test"

Success! Data written to: auth/chakravyuh/role/app1

Now lets login back as app1.

vault write auth/chakravyuh/login username=app1 password=app1

Key                  Value
---                  -----
token                s.pid0aK99QwqF59gm3byGJ8c1
token_accessor       LMSRw1ilgiGBpc9hD512Y5yv
token_duration       50m
token_renewable      true
token_policies       ["default" "test"]
identity_policies    []
policies             ["default" "test"]

Note the policy has changed. We can confirm that as well:

export VAULT_MINE=s.m1zZn0uwiDaUmeg9wMGep7Pg

vault login $VAULT_MINE

Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                s.m1zZn0uwiDaUmeg9wMGep7Pg
token_accessor       H6IBmJsy7RkXimfgzQ00L6qu
token_duration       49m27s
token_renewable      true
token_policies       ["default" "test"]
identity_policies    []
policies             ["default" "test"]



vault token capabilities chowkidar/test
create, delete, read, update

vault read chowkidar/test
Key        Value
---        -----
message    Hello world


write some data now:

vault write chowkidar/newtest "new message"="hello again"
Success! Data written to: chowkidar/newtest

vault read chowkidar/newtest
Key            Value
---            -----
new message    hello again


Code:

Now open up the code. Lets look at the chowkidar plugin first. Open code in ~/c-and-c/code/chowkidar/

Go to function

func (b *backend) paths() []*framework.Path

Here you can see the different operations we support for the paths that come in. The operations are ReadOperation, UpdateOperation, CreateOperation and DeleteOperation. This matches the permissions we specify. The callbacks are specified. Lets look at the UpdateOperation callback function handleWrite().

The code is straightforward enough to parse. Make sure that the Token is present, then make sure data is present. We get the path. Now notice that we are writing the data to a file, one file per path specified! That is very interesting. So we should be able to open that file and get the data! In our working directory, we do ls and we can see two files - test.txt and newtest.txt. Lets look at both:

 cat test.txt
{"message":"Hello world"}

 cat newtest.txt 
{"hello":"world"}

And that is it! The kv plugin we used stored all data in memory. You can write a plugin that writes to some fancy location you want, or you can push it to a router/switch or anything you want to do with it! You can encrypt the data and send it some where else. Its really upto your imagination.

The rest of the operations must be quite easy to understand now. Lets look at handleRead(). It reads this file and gives the raw data back.

handleDelete() removes the file.

Note that here we dont handle the policy at all. Where is the policy check to see if the user can access this location or not? So this is the great part - once a policy is given to vault, it will handle running the policy for the specific path. We dont have to do anything!

Now lets see the chakravyuh plugin. Open ~/c-and-c/code/chakravyuh/main.go. This file is a bit longer, but dont panic.

In this file, look at the function Backend(). You can see certain paths, the ones that we used:
- login: you specify username and password
- role: you specify the policy here

The callbacks are there for UpdateOperation and ReadOperation. Lets explore those functions.

Look at pathAuthPolicy(). This is where the policy name is received and is stored into setRoleEntry().

Look at pathAuthLogin(). This is where you can login. This takes the username and password and compares them. Here we have hardcoded password for "app1" as "app1". We check if the password matches cred[username] and if it does, then we provide the policy that was configured before back to the backend.

This is how we set everything up.

Lets do one thing. Lets disable this chakravyuh plugin.

First login as root:

vault login $VAULT_ROOT
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                root
token_accessor       gzBXAqRupEtlL18v17FYalQr
token_duration       ∞
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]


vault auth disable chakravyuh


Success! Disabled the auth method (if it existed) at: chakravyuh/

You can see now that vault doesnt know about path auth/chakravyuh anymore.

vault write auth/chakravyuh/login username=app1 password=app1
Error writing data to auth/chakravyuh/login: Error making API request.

URL: PUT http://127.0.0.1:8200/v1/auth/chakravyuh/login
Code: 404. Errors:

* no handler for route 'auth/chakravyuh/login'

Lets change password for username "app1" to "mynewpassword".

cd ../code/chakravyuh/

Instead of this line:
	cred["app1"]="app1"
put in this line:
	cred["app1"]="mynewpassword"

Now build and update this plugin.


go build -o ~/c-and-c/plugins/chakravyuh
ls -al ~/c-and-c/plugins/chakravyuh 
-rwxrwxr-x 1 seccon seccon 16905595 Aug 19 21:19 /home/seccon/c-and-c/plugins/chakravyuh

Now load the plugin again. The easiest way is to restart the vault server.

~/c-and-c/working/start-vault.sh

WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

You may need to set the following environment variable:

    $ export VAULT_ADDR='http://127.0.0.1:8200'

The unseal key and root token are displayed below in case you want to
seal/unseal the Vault or re-authenticate.

Unseal Key: TwjpMngIPonGYmcqaNAKdF4HbyXi8B3b7KsdJlV4J2c=
Root Token: root

The following dev plugins are registered in the catalog:
    - chakravyuh
    - chowkidar

Development mode should NOT be used in production installations!


vault auth enable -path=chakravyuh -plugin-name=chakravyuh plugin
Success! Enabled chakravyuh auth method at: chakravyuh/

vault write auth/chakravyuh/login username=app1 password=app1
Error writing data to auth/chakravyuh/login: Error making API request.

URL: PUT http://127.0.0.1:8200/v1/auth/chakravyuh/login
Code: 500. Errors:

* Verification Failed



Now login with the new password:

vault write auth/chakravyuh/login username=app1 password=newpassword
Key                  Value
---                  -----
token                s.tR5dPa3Up2H7TdScdKM4jIs5
token_accessor       WqgJppLd4kH1i3VlxQQjHBXh
token_duration       50m
token_renewable      true
token_policies       ["default"]
identity_policies    []
policies             ["default"]


vault login s.tR5dPa3Up2H7TdScdKM4jIs5
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                s.tR5dPa3Up2H7TdScdKM4jIs5
token_accessor       WqgJppLd4kH1i3VlxQQjHBXh
token_duration       49m47s
token_renewable      true
token_policies       ["default"]
identity_policies    []
policies             ["default"]


vault token capabilities secret/data/mysecret
deny


Production server.

kill the existing vault server
killall -9 vault

Launch it without dev:

vault server
Must specify at least one config path using -config

I am pasting the config in the chat window

storage "inmem" {
}

listener "tcp" {
  address     = "127.0.0.1:8200"
  tls_disable = 1
}

api_addr = "http://127.0.0.1:8200"
cluster_addr = "https://127.0.0.1:8201"
ui = true


cat > config.hcl

and paste the above. Hit ^D at the end. Now do

vault server -config=config.hcl

Now in the other window, do

 vault status
Key                Value
---                -----
Seal Type          shamir
Initialized        false
Sealed             true
Total Shares       0
Threshold          0
Unseal Progress    0/0
Unseal Nonce       n/a
Version            n/a
HA Enabled         false


You can see that vault is not initialized and it is sealed. In dev mode it is unsealed. lets initialize the vault.

 vault operator init
Unseal Key 1: tuI1IATaGZ9Q590WJ1RNqXYho0KR5tocVLyVstWYowbU
Unseal Key 2: Ru052pGGYOZTGKQ2kG+J/sHYJzybgeqEHjWei5H50vBi
Unseal Key 3: Tdqat28B7xFvKO6x55xNOSb2rnJSFiQ6yuE2hnwPRhcC
Unseal Key 4: fWn/+er5NLbZAyUuYHMyd27JbFv3oX8Cc6szDGNrEQ40
Unseal Key 5: b3xgIEJW1dt4tEVoRZfUsr+ILiqilwkVg1khIKqSeSir

Initial Root Token: s.JjvyNMhorVQDhgZencnHHZxk

Vault initialized with 5 key shares and a key threshold of 3. Please securely
distribute the key shares printed above. When the Vault is re-sealed,
restarted, or stopped, you must supply at least 3 of these keys to unseal it
before it can start servicing requests.

Vault does not store the generated master key. Without at least 3 key to
reconstruct the master key, Vault will remain permanently sealed!

It is possible to generate new unseal keys, provided you have a quorum of
existing unseal keys shares. See "vault operator rekey" for more information.
seccon@ubuntu:~/c-and-c/working$ vault status
Key                Value
---                -----
Seal Type          shamir
Initialized        true
Sealed             true
Total Shares       5
Threshold          3
Unseal Progress    0/3
Unseal Nonce       n/a
Version            1.5.0
HA Enabled         false


You can see multiple unseal keys. These are like James Bond / Mission Impossible movies. You need atleast 3 keys to unseal the vault. You can check that by doing some operations.

vault kv put secrets/mypw "cec"="mine"
Error making API request.

URL: GET http://127.0.0.1:8200/v1/sys/internal/ui/mounts/secrets/mypw
Code: 503. Errors:

* error performing token check: Vault is sealed

So lets unseal the vault.

vault operator unseal
Unseal Key (will be hidden): 
Key                Value
---                -----
Seal Type          shamir
Initialized        true
Sealed             true
Total Shares       5
Threshold          3
Unseal Progress    1/3
Unseal Nonce       00ffdf99-bac0-c1c6-f7c0-a7b3a8125dae
Version            1.5.0
HA Enabled         false

You can also unseal via REST API

curl \
    --request PUT \
    --data @unseal.json \
    http://127.0.0.1:8200/v1/sys/unseal

{"type":"shamir","initialized":true,"sealed":true,"t":3,"n":5,"progress":2,"nonce":"00ffdf99-bac0-c1c6-f7c0-a7b3a8125dae","version":"1.5.0","migration":false,"recovery_seal":false,"storage_type":"inmem"}

You can see the progress as well. We have finished 2 keys. Can I get it incorrect random values?

vault status
Key                Value
---                -----
Seal Type          shamir
Initialized        true
Sealed             true
Total Shares       5
Threshold          3
Unseal Progress    2/3
Unseal Nonce       00ffdf99-bac0-c1c6-f7c0-a7b3a8125dae
Version            1.5.0
HA Enabled         false

What if I give the same key twice?

Accepted but no dice.

Ok, so lets give another key but the 5th one.

vault operator unseal
Unseal Key (will be hidden): 
Key             Value
---             -----
Seal Type       shamir
Initialized     true
Sealed          false
Total Shares    5
Threshold       3
Version         1.5.0
Cluster Name    vault-cluster-07903e51
Cluster ID      dbba8d49-1e3e-1b0e-3a96-570348f34965
HA Enabled      false

But thats not enough! There needs to be policies:

vault kv put secrets/test "message"="hello"
Error making API request.

URL: GET http://127.0.0.1:8200/v1/sys/internal/ui/mounts/secrets/test
Code: 403. Errors:

* preflight capability check returned 403, please ensure client's policies grant access to path "secrets/test/"


We are not logged in by default. We need to login.

 vault login s.JjvyNMhorVQDhgZencnHHZxk
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                s.JjvyNMhorVQDhgZencnHHZxk
token_accessor       9JJIZLTb9SbkPn2aFbZGNyhB
token_duration       ∞
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]

But even this is not enough - we definitely need policies.

You can see how this enhances security.

So thats the idea. Think about cloud based security and how you deal with it nowadays.


